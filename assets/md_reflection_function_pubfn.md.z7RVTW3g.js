import{_ as s,c as a,o as n,ae as t}from"./chunks/framework.jSsAt8jZ.js";const c=JSON.parse('{"title":"<function.hpp> 函数","description":"","frontmatter":{},"headers":[],"relativePath":"md/reflection/function/pubfn.md","filePath":"md/reflection/function/pubfn.md"}'),h={name:"md/reflection/function/pubfn.md"};function e(p,i,l,k,d,r){return n(),a("div",null,i[0]||(i[0]=[t('<h1 id="function-hpp-函数" tabindex="-1"><code>&lt;function.hpp&gt;</code> 函数 <a class="header-anchor" href="#function-hpp-函数" aria-label="Permalink to &quot;`&lt;function.hpp&gt;` 函数&quot;">​</a></h1><h2 id="make-function" tabindex="-1">make_function <a class="header-anchor" href="#make-function" aria-label="Permalink to &quot;make_function&quot;">​</a></h2><p>适用于function类的工厂函数，通过静态域函数、对象实例函数的指针构造一个function对象用于反射</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rainy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reflection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make_function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h3><p><code>fx</code>: fx的类型必须能够满足静态域函数、对象实例函数的任一一个的定义。或者说，此Fx类型的参数必须能够用于构造function对象。否则将引发编译错误！</p><h3 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>返回绑定fx指向的调用实体的function对象</p><h2 id="invoke" tabindex="-1">invoke <a class="header-anchor" href="#invoke" aria-label="Permalink to &quot;invoke&quot;">​</a></h2><p>允许用户以类<code>std::invoke/rainy::utility::invoke</code>的方式，调用function类函数对象。且自动推导值的类别</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rainy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">utility</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">any</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> function</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">object_view</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="参数-1" tabindex="-1">参数 <a class="header-anchor" href="#参数-1" aria-label="Permalink to &quot;参数&quot;">​</a></h3><p><code>fn</code>: function对象，必须是有效的（存有可调用函数指针） <code>instance</code>: 如果目标是个对象实例函数，则此处需提供对象实例函数的引用，否则请使用<code>non_exists_instance</code>对象 <code>args...</code>: 任意数量的参数，用于提供给目标</p><h3 id="返回值-1" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-1" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>如果调用目标的返回类型不为void，则此部分返回的any将包含实际的返回值内容。如，目标调用返回<code>int</code>类型，数据为<code>42</code>。则<code>any</code>将包含<code>int</code>类型的rtti信息和数据<code>42</code>。</p><h3 id="备注" tabindex="-1">备注 <a class="header-anchor" href="#备注" aria-label="Permalink to &quot;备注&quot;">​</a></h3><p>若args的类型与对应的目标参数类型并不完全一致，则function可能会尝试从rainy::utility::any_converter中进行类型转换。例如，float可转换为int，int可转换为float这类。但是，部分类型可能会存在转换失败问题，或是潜在的未定义行为，详见warning部分</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>invoke的调用中，Args的类型均以<code>原样</code>被提供给调用目标。因此，诸如下列的对象：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rainy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">utility</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">any</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> any_a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in_place_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rainy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">utility</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>在推导中，仍然会以rainy::utility::any进行提供。且，若类型不匹配，在转换的时候，可能会产生运行时强制终止的崩溃。 此外，对于any_converter，目前已知以下问题：</p><ol><li>无法对不同类型进行引用级转换，如int&amp;无法转换为long&amp;，仅支持诸如int&amp;转换为const int&amp;这样的同类型引用转换</li><li>any_converter无法直接将当前类型转换为另一个类型的引用，仅支持值的构造（有可能导致UB）</li></ol></div>',18)]))}const E=s(h,[["render",e]]);export{c as __pageData,E as default};
