## 概要

function类是类似于标准库的function类，但是存在差异。例如，该类是非模板类。function类会根据函数类型自动生成调用代码并进行绑定。在使用中，function类通常被用于采集类型识别信息、动态的调用某些可调用函数和序列化某些信息。另注，详细机制请参见内部机制页面。

该类具有如下特性。

- 支持默认参数绑定
- 支持lambda、函数对象、成员函数指针、函数指针的绑定
- 动态调用
- 重绑定不同签名函数
- 动态检索目标属性
- 支持检查可调用性
- 可有限的对参数进行转换
- 无rtti

另外，具有如下缺点。

- 存在类型擦除的性能开销
- 不支持bind表达式（无法直接解析）
- 二进制膨胀
- 不具备完整的类型安全机制

上述缺点中，例如function类内部会实例化内部模板代码用于解析或检索等操作，因此会导致二进制膨胀。另外，由于模板实例化的特性，类型擦除被大量应用。以及，bind表达式因为具有多个重载导致无法直接解析。另外，类型安全是通过内建规则实现的。因此，如果需要完整的、原生的C++类型安全机制，而非动态调用。可考虑使用rainy-toolkit提供的delegate模板类，而非function类。例如，delegate类具有如下特性。

- 类型安全
- 优化潜力较高（编译时信息已知）
- 检索目标属性
- 无rtti
- 重绑定同签名函数

因此，如果希望使用类型安全和检索类型信息而不希望使用动态调用，使用delegate类是相对较好的选择。但是也同样存在如下缺点。

- 无法动态调用
- 统一存储难
- 灵活性相比function类较低
- 某些函数类型需显式实例化
- 不支持默认参数调用

::: tip
function类对象是可重入的，不具备线程安全机制。因此，若目标代码涉及数据竞争条件，请手动编写同步代码。或使用pal模块中`threading.hpp`的`create_synchronized_task`简化同步代码。
:::